<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>PetaVision: OpenPV/src/layers/InputLayer.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PetaVision
   &#160;<span id="projectnumber">Alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('InputLayer_8hpp_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">InputLayer.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// InputLayer</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">// Base class for layers that take their input from file IO</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#ifndef __INPUTLAYER_HPP__</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="preprocessor">#define __INPUTLAYER_HPP__</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#include &quot;HyPerLayer.hpp&quot;</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#include &quot;checkpointing/CheckpointableFileStream.hpp&quot;</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &quot;columns/HyPerCol.hpp&quot;</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &quot;components/BatchIndexer.hpp&quot;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &quot;structures/Buffer.hpp&quot;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &quot;utils/BorderExchange.hpp&quot;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &quot;utils/BufferUtilsRescale.hpp&quot;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &lt;random&gt;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacePV.html">PV</a> {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno"><a class="line" href="classPV_1_1InputLayer.html">   20</a></span>&#160;<span class="keyword">class </span><a class="code" href="classPV_1_1InputLayer.html">InputLayer</a> : <span class="keyword">public</span> <a class="code" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> {</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  <span class="keyword">protected</span>:</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   <span class="comment">// inputPath: Either an individual file to load, or a .txt list of files to load.</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_inputPath(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   <span class="comment">// offsetX: offset in X direction</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;   <span class="comment">// offsetY: offset in Y direction</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;   <span class="comment">// Defines an offset in image space where the column is viewing the image</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> ioParam_offsets(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   <span class="comment">// maxShiftX: max random shift in X direction</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;   <span class="comment">// maxShiftY: max random shift in Y direction</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   <span class="comment">// Defines the max random shift in image space</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> ioParam_maxShifts(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;   <span class="comment">// xFlipEnabled: When true, 50% chance to mirror input horizontally</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;   <span class="comment">// yFlipEnabled: When true, 50% chance to mirror input vertically</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> ioParam_flipsEnabled(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;   <span class="comment">// xFlipToggle: When true, flip every jitter interval instead of randomly</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;   <span class="comment">// yFlipToggle: When true, flip every jitter interval instead of randomly</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> ioParam_flipsToggle(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;   <span class="comment">// jitterChangeInterval: interval measured in displayPeriods</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;   <span class="comment">// Defines the frequency of the random shifts updates</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> ioParam_jitterChangeInterval(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;   <span class="comment">// offsetAnchor: Defines where the anchor point is for the offsets.</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;   <span class="comment">// Specified as a 2 character string, &quot;xy&quot;</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;   <span class="comment">// x can be &#39;l&#39;, &#39;c&#39;, or &#39;r&#39; for left, center, right respectively &lt;br /&gt;</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;   <span class="comment">// y can be &#39;t&#39;, &#39;c&#39;, or &#39;b&#39; for top, center, bottom respectively &lt;br /&gt;</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_offsetAnchor(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;   <span class="comment">// autoResizeFlag: Whether to scale the image to fit layer dimensions</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_autoResizeFlag(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;   <span class="comment">// aspectRatioAdjustment: either &quot;crop&quot; or &quot;pad&quot;</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_aspectRatioAdjustment(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;   <span class="comment">// interpolationMethod: either &quot;bicubic&quot; or &quot;nearestNeighbor&quot;.</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_interpolationMethod(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;   <span class="comment">// inverseFlag: If set to true, inverts the input: pixels are mapped linearly</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;   <span class="comment">// so that the max pixel value is mapped to the min and vice versa.</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_inverseFlag(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;   <span class="comment">// normalizeLuminanceFlag: If set to true, will normalize the image.</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;   <span class="comment">// The normalization method is determined by the normalizeStdDev parameter.</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_normalizeLuminanceFlag(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;   <span class="comment">// normalizeStdDev: This flag is used if normalizeLuminanceFlag is true.</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;   <span class="comment">// If normalizeStdDev is set to true, the image will normalize with a mean of 0 and std of 1</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;   <span class="comment">// If normalizeStdDev is set to false, the image will normalize with a min of 0 and a max of 1</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;   <span class="comment">// If all pixels are equal, the image will normalize so that all pixels are zero.</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_normalizeStdDev(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;   <span class="comment">// padValue: If the image is being padded (image smaller than layer), the value to use for</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;   <span class="comment">// padding</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_padValue(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;   <span class="comment">// initVType: InputLayers do not have a V, do not set</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPV_1_1InputLayer.html#ae52c187ac0eedc919213ab2a725e86df">ioParam_InitVType</a>(<span class="keyword">enum</span> ParamsIOFlag ioFlag) <span class="keyword">override</span>;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;   <span class="comment">// triggerLayerName: InputLayer and derived classes do not use triggering, and always set</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;   <span class="comment">// triggerLayerName to NULL.</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPV_1_1InputLayer.html#a8c84fd873f563ad4f21d0b073aab15ca">ioParam_triggerLayerName</a>(<span class="keyword">enum</span> ParamsIOFlag ioFlag) <span class="keyword">override</span>;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;   <span class="comment">// displayPeriod: the number of timesteps each input is displayed before switching to the next.</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;   <span class="comment">// If this is &lt;= 0 or inputPath does not end in .txt, assumes the input is a single file and will</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;   <span class="comment">// not change.</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_displayPeriod(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;   <span class="comment">// start_frame_index: Array specifying the file indices to start at.</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;   <span class="comment">// If displayPeriod &lt;= 0, this determines which index from the file list will be used.</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_start_frame_index(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;   <span class="comment">// skip_frame_index: Array specifying how much to increment the file index by each displayPeriod</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;   <span class="comment">// for each batch</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_skip_frame_index(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;   <span class="comment">// writeFrameToTimestamp: if true, then every time the frame is updated, it writes the frame</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;   <span class="comment">// number,</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;   <span class="comment">// the time and the image filename to a file. The file is placed in a directory &quot;timestamps&quot; in</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;   <span class="comment">// the outputPath</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;   <span class="comment">// directory, and the filename is the layer name appended with &quot;.txt&quot;.</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_writeFrameToTimestamp(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;   <span class="comment">// resetToStartOnLoop: If false, then when the end of file for the inputPath file is reached,</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;   <span class="comment">// it rewinds to index 0. Otherwise, it rewinds to the index it began at (possibly</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;   <span class="comment">// start_frame_index).</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_resetToStartOnLoop(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;   <span class="comment">// batchMethod: Specifies how to split the file for batches.</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;   <span class="comment">// byFile: Each batch skips nbatch, and starts staggered from the beginning of the file list</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;   <span class="comment">// byList: Each batch skips 1, and starts at index = numFrames/numBatch</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;   <span class="comment">// bySpecified: User specified start_frame_index and skip_frame_index, one for each batch</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;   <span class="comment">// random: Randomizes the order of the given file. Does not duplicate indices until all are used</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_batchMethod(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;   <span class="comment">// Random seed used when batchMethod == random.</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_randomSeed(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;   <span class="comment">// useInputBCFlag: Specifies if the input should be scaled to fill margins</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> ioParam_useInputBCflag(<span class="keyword">enum</span> ParamsIOFlag ioFlag);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keyword">protected</span>:</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;   <a class="code" href="classPV_1_1InputLayer.html">InputLayer</a>() {}</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;   <span class="keywordtype">int</span> <a class="code" href="classPV_1_1InputLayer.html#a0939032acfe75d5bab94c439b8233a70">scatterInput</a>(<span class="keywordtype">int</span> localBatchIndex, <span class="keywordtype">int</span> mpiBatchIndex);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;   <span class="keywordtype">int</span> initialize(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;   <span class="comment">// Returns PV_SUCCESS if offsetAnchor is a valid anchor string, PV_FAILURE otherwise.</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;   <span class="comment">// (two characters long; first characters one of &#39;t&#39;, &#39;c&#39;, or &#39;b&#39;; second characters one of &#39;l&#39;,</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;   <span class="comment">// &#39;c&#39;, or &#39;r&#39;)</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;   <span class="keywordtype">int</span> checkValidAnchorString(<span class="keyword">const</span> <span class="keywordtype">char</span> *offsetAnchor);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classPV_1_1InputLayer.html#a09949638cf7d516ce9ad6dfff2475031">normalizePixels</a>(<span class="keywordtype">int</span> batchElement);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> allocateV() <span class="keyword">override</span>;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> initializeV() <span class="keyword">override</span>;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">void</span> initializeActivity() <span class="keyword">override</span>;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classPV_1_1InputLayer.html#a3aa228af1576848e24babc60abe05a39">ioParamsFillGroup</a>(<span class="keyword">enum</span> ParamsIOFlag ioFlag) <span class="keyword">override</span>;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;   <span class="keyword">virtual</span> Response::Status registerData(<a class="code" href="classPV_1_1Checkpointer.html">Checkpointer</a> *checkpointer) <span class="keyword">override</span>;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;   <span class="keyword">virtual</span> Response::Status readStateFromCheckpoint(<a class="code" href="classPV_1_1Checkpointer.html">Checkpointer</a> *checkpointer) <span class="keyword">override</span>;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classPV_1_1InputLayer.html#a849009ff72a670f92895cce9ee555eca">getDeltaUpdateTime</a>() <span class="keyword">override</span>;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;   <span class="comment">// Method that signals when to load the next file.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;   <span class="comment">// Can be overridden for different file list logic in subclasses.</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> readyForNextFile();</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classPV_1_1InputLayer.html#abca7df27e7a6356bacf07e20b0043fda">countInputImages</a>() = 0;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;   <span class="keyword">virtual</span> <a class="code" href="classPV_1_1Buffer.html">Buffer&lt;float&gt;</a> <a class="code" href="classPV_1_1InputLayer.html#aa5eb79078d3731ba45e778f648fed1a8">retrieveData</a>(<span class="keywordtype">int</span> inputIndex) = 0;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;   <span class="keywordtype">void</span> <a class="code" href="classPV_1_1InputLayer.html#aabc8d136ac737da1d6dd2e72c286b5b2">retrieveInput</a>(<span class="keywordtype">double</span> timef, <span class="keywordtype">double</span> dt);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;   <span class="keywordtype">void</span> <a class="code" href="classPV_1_1InputLayer.html#add3edb991c3ddcf8e29a4e357fc229db">retrieveInputAndAdvanceIndex</a>(<span class="keywordtype">double</span> timef, <span class="keywordtype">double</span> dt);</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;   <span class="keywordtype">void</span> initializeBatchIndexer();</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;   <a class="code" href="classPV_1_1InputLayer.html">InputLayer</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc);</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;   <span class="keyword">virtual</span> ~<a class="code" href="classPV_1_1InputLayer.html">InputLayer</a>();</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">int</span> requireChannel(<span class="keywordtype">int</span> channelNeeded, <span class="keywordtype">int</span> *numChannelsResult) <span class="keyword">override</span>;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;   <span class="keywordtype">void</span> makeInputRegionsPointer() { mNeedInputRegionsPointer = <span class="keyword">true</span>; }</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;   <span class="keyword">virtual</span> Response::Status allocateDataStructures() <span class="keyword">override</span>;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;   <span class="keyword">virtual</span> Response::Status updateState(<span class="keywordtype">double</span> time, <span class="keywordtype">double</span> dt) <span class="keyword">override</span>;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno"><a class="line" href="classPV_1_1InputLayer.html#a8e993dd5a30ede37722a5e9d5a062662">  201</a></span>&#160;   <span class="keyword">virtual</span> std::string <a class="code" href="classPV_1_1InputLayer.html#a8e993dd5a30ede37722a5e9d5a062662">describeInput</a>(<span class="keywordtype">int</span> index) { <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;&quot;</span>); }</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> activityIsSpiking()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;   <span class="keywordtype">int</span> getDisplayPeriod() { <span class="keywordflow">return</span> mDisplayPeriod; }</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;   <span class="keywordtype">int</span> getStartIndex(<span class="keywordtype">int</span> batchIndex) { <span class="keywordflow">return</span> mStartFrameIndex.at(batchIndex); }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;   <span class="keywordtype">int</span> getSkipIndex(<span class="keywordtype">int</span> batchIndex) { <span class="keywordflow">return</span> mSkipFrameIndex.at(batchIndex); }</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;   <span class="keyword">const</span> std::string &amp;getInputPath()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mInputPath; }</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno"><a class="line" href="classPV_1_1InputLayer.html#a0d450cd16682e804ad00fed1df6f3214">  216</a></span>&#160;   <span class="keyword">virtual</span> std::string <span class="keyword">const</span> &amp;<a class="code" href="classPV_1_1InputLayer.html#a0d450cd16682e804ad00fed1df6f3214">getCurrentFilename</a>(<span class="keywordtype">int</span> localBatchElement, <span class="keywordtype">int</span> mpiBatchIndex)<span class="keyword"> const </span>{</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="keywordflow">return</span> mInputPath;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;   }</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;   <span class="keywordtype">float</span> *getInputRegionsAllBatchElements() { <span class="keywordflow">return</span> mInputRegionsAllBatchElements.data(); }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <span class="keyword">private</span>:</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;   <span class="keywordtype">void</span> <a class="code" href="classPV_1_1InputLayer.html#a926ba95ba74fbc23de3276f96f48670d">fitBufferToGlobalLayer</a>(<a class="code" href="classPV_1_1Buffer.html">Buffer&lt;float&gt;</a> &amp;buffer, <span class="keywordtype">int</span> blockBatchElement);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;   <span class="keywordtype">void</span> cropToMPIBlock(<a class="code" href="classPV_1_1Buffer.html">Buffer&lt;float&gt;</a> &amp;buffer);</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <span class="keyword">protected</span>:</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;   <span class="comment">// If mAutoResizeFlag is enabled, do we crop the edges or pad the edges with mPadValue?</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;   BufferUtils::RescaleMethod mRescaleMethod;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;   <span class="comment">// If mAutoResizeFlag is enabled, do we rescale with bicubic or nearest neighbor filtering?</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;   BufferUtils::InterpolationMethod mInterpolationMethod = BufferUtils::BICUBIC;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;   <span class="comment">// When cropping or resizing, which side of the canvas is the origin?</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;   <a class="code" href="classPV_1_1Buffer.html">Buffer&lt;float&gt;::Anchor</a> mAnchor = <a class="code" href="classPV_1_1Buffer.html">Buffer&lt;float&gt;::CENTER</a>;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;   <span class="comment">// Flag that enables rescaling input buffer to layer dimensions instead of just cropping</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;   <span class="keywordtype">bool</span> mAutoResizeFlag = <span class="keyword">false</span>;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;   <span class="comment">// Flag that inverts input buffer during post process step</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;   <span class="keywordtype">bool</span> mInverseFlag = <span class="keyword">false</span>;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;   <span class="comment">// Flag that enables scaling input buffer to extended region instead of restricted region</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;   <span class="keywordtype">bool</span> mUseInputBCflag = <span class="keyword">false</span>;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;   <span class="comment">// Flag enabling normalization in the post process step</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;   <span class="keywordtype">bool</span> mNormalizeLuminanceFlag = <span class="keyword">false</span>;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;   <span class="comment">// If true and normalizeLuminanceFlag == true, normalize the standard deviation to 1 and mean = 0</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;   <span class="comment">// If false and normalizeLuminanceFlag == true, nomalize max = 1, min = 0</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;   <span class="keywordtype">bool</span> mNormalizeStdDev = <span class="keyword">true</span>;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;   <span class="comment">// Amount to translate input buffer before scattering but after rescaling</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;   <span class="keywordtype">int</span> mOffsetX = 0;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;   <span class="keywordtype">int</span> mOffsetY = 0;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;   <span class="comment">// If nonzero, create a sample by shifting image randomly in [-maxRandomShiftX, maxRandomShiftX]</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;   <span class="comment">// x [-maxRandomShiftY, maxRandomShiftY]</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;   <span class="keywordtype">int</span> mMaxShiftX = 0;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;   <span class="keywordtype">int</span> mMaxShiftY = 0;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;   <span class="comment">// How often to change random shifts (measured in displayPeriods)</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;   <span class="keywordtype">int</span> mJitterChangeInterval = 1;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;   <span class="comment">// Are horizontal or vertical mirror flips enabled during the augmentation stage?</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;   <span class="keywordtype">bool</span> mXFlipEnabled = <span class="keyword">false</span>;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;   <span class="keywordtype">bool</span> mYFlipEnabled = <span class="keyword">false</span>;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;   <span class="comment">// If this is true, toggle mirror flips each time instead of randomly selecting</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;   <span class="keywordtype">bool</span> mXFlipToggle = <span class="keyword">false</span>;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;   <span class="keywordtype">bool</span> mYFlipToggle = <span class="keyword">false</span>;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;   <span class="comment">// Random seed used when batchMethod == random</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;   <span class="keywordtype">int</span> mRandomSeed = 123456789;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;   <span class="comment">// Object to handle assigning file indices to batch element</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;   std::unique_ptr&lt;BatchIndexer&gt; mBatchIndexer;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;   BatchIndexer::BatchMethod mBatchMethod;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keyword">private</span>:</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;   <span class="comment">// Data read from disk, one per batch element.</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;   std::vector&lt;Buffer&lt;float&gt;&gt; mInputData;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;   <span class="comment">// The parts of the mInputData buffers occupied by image data, as opposed to gaps created by</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;   <span class="comment">// offsets or resizing with padding. When mInputData[b] is first filled using retrieveData,</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;   <span class="comment">// mInputRegion[b] is created as a buffer of the same size filled with ones.</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;   <span class="comment">// As operations that translate or resize are applied to mInputData[b], the same operation is</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;   <span class="comment">// applied to mInputRegion[b]. When normalizePixels() normalizes or scatterInput() copies to the</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;   <span class="comment">// clayer activity, only those pixels where mInputRegion[b] is nonzero are used.</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;   std::vector&lt;Buffer&lt;float&gt;&gt; mInputRegion;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;   <span class="keywordtype">bool</span> mNeedInputRegionsPointer = <span class="keyword">false</span>;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;   <span class="comment">// A vector containing the contents of the mInputRegion buffers, allocated as a single array</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;   <span class="comment">// of size getNumExtendedAllBatches.</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;   <span class="comment">// Will not be allocated unless the makeInputRegionsPointer() method is called before the</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;   <span class="comment">// AllocateData stage.</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;   std::vector&lt;float&gt; mInputRegionsAllBatchElements;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;   <span class="comment">// BorderExchange object for boundary exchange</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;   <a class="code" href="classPV_1_1BorderExchange.html">BorderExchange</a> *mBorderExchanger = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;   <span class="comment">// Value to fill empty region with when using padding</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;   <span class="keywordtype">float</span> mPadValue = 0.0f;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;   <span class="comment">// Path to input file or list of input files</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;   std::string mInputPath;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;   <span class="comment">// Filepointer to output file used when mWriteFrameToTimestamp == true</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;   <a class="code" href="classPV_1_1CheckpointableFileStream.html">CheckpointableFileStream</a> *mTimestampStream = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;   <span class="comment">// Number of timesteps an input file is displayed before advancing the file list. If &lt;= 0, the</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;   <span class="comment">// file never changes.</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;   <span class="keywordtype">int</span> mDisplayPeriod = 0;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;   <span class="comment">// When reaching the end of the file list, do we reset to 0 or to start_index?</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;   <span class="comment">// This parameter is read only if using batchMethod=bySpecified</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;   <span class="keywordtype">bool</span> mResetToStartOnLoop = <span class="keyword">false</span>;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;   <span class="comment">// Flag to write filenames and batch indices to disk as they are loaded</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;   <span class="keywordtype">bool</span> mWriteFrameToTimestamp = <span class="keyword">true</span>;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;   <span class="comment">// An array of starting file list indices, one per batch</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;   std::vector&lt;int&gt; mStartFrameIndex;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;   <span class="comment">// An array indicating how far to advance each index, one per batch</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;   std::vector&lt;int&gt; mSkipFrameIndex;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;   <span class="comment">// Random number generator for jitter</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;   std::mt19937 mRNG;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;   <span class="comment">// An array of random shifts in x direction, one per batch</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;   std::vector&lt;int&gt; mRandomShiftX;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;   <span class="comment">// An array of random shifts in y direction, one per batch</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;   std::vector&lt;int&gt; mRandomShiftY;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;   <span class="comment">// Same for mirror flips</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;   std::vector&lt;bool&gt; mMirrorFlipX;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;   std::vector&lt;bool&gt; mMirrorFlipY;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;};</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;} <span class="comment">// end namespace PV</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="preprocessor">#endif</span></div><div class="ttc" id="classPV_1_1InputLayer_html_aa5eb79078d3731ba45e778f648fed1a8"><div class="ttname"><a href="classPV_1_1InputLayer.html#aa5eb79078d3731ba45e778f648fed1a8">PV::InputLayer::retrieveData</a></div><div class="ttdeci">virtual Buffer&lt; float &gt; retrieveData(int inputIndex)=0</div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a926ba95ba74fbc23de3276f96f48670d"><div class="ttname"><a href="classPV_1_1InputLayer.html#a926ba95ba74fbc23de3276f96f48670d">PV::InputLayer::fitBufferToGlobalLayer</a></div><div class="ttdeci">void fitBufferToGlobalLayer(Buffer&lt; float &gt; &amp;buffer, int blockBatchElement)</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00244">InputLayer.cpp:244</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a0939032acfe75d5bab94c439b8233a70"><div class="ttname"><a href="classPV_1_1InputLayer.html#a0939032acfe75d5bab94c439b8233a70">PV::InputLayer::scatterInput</a></div><div class="ttdeci">int scatterInput(int localBatchIndex, int mpiBatchIndex)</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00159">InputLayer.cpp:159</a></div></div>
<div class="ttc" id="classPV_1_1BorderExchange_html"><div class="ttname"><a href="classPV_1_1BorderExchange.html">PV::BorderExchange</a></div><div class="ttdef"><b>Definition:</b> <a href="BorderExchange_8hpp_source.html#l00015">BorderExchange.hpp:15</a></div></div>
<div class="ttc" id="classPV_1_1HyPerCol_html"><div class="ttname"><a href="classPV_1_1HyPerCol.html">PV::HyPerCol</a></div><div class="ttdef"><b>Definition:</b> <a href="HyPerCol_8hpp_source.html#l00041">HyPerCol.hpp:41</a></div></div>
<div class="ttc" id="classPV_1_1HyPerLayer_html"><div class="ttname"><a href="classPV_1_1HyPerLayer.html">PV::HyPerLayer</a></div><div class="ttdef"><b>Definition:</b> <a href="HyPerLayer_8hpp_source.html#l00064">HyPerLayer.hpp:64</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a0d450cd16682e804ad00fed1df6f3214"><div class="ttname"><a href="classPV_1_1InputLayer.html#a0d450cd16682e804ad00fed1df6f3214">PV::InputLayer::getCurrentFilename</a></div><div class="ttdeci">virtual std::string const &amp; getCurrentFilename(int localBatchElement, int mpiBatchIndex) const </div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8hpp_source.html#l00216">InputLayer.hpp:216</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_add3edb991c3ddcf8e29a4e357fc229db"><div class="ttname"><a href="classPV_1_1InputLayer.html#add3edb991c3ddcf8e29a4e357fc229db">PV::InputLayer::retrieveInputAndAdvanceIndex</a></div><div class="ttdeci">void retrieveInputAndAdvanceIndex(double timef, double dt)</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00149">InputLayer.cpp:149</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a849009ff72a670f92895cce9ee555eca"><div class="ttname"><a href="classPV_1_1InputLayer.html#a849009ff72a670f92895cce9ee555eca">PV::InputLayer::getDeltaUpdateTime</a></div><div class="ttdeci">virtual double getDeltaUpdateTime() override</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00406">InputLayer.cpp:406</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a09949638cf7d516ce9ad6dfff2475031"><div class="ttname"><a href="classPV_1_1InputLayer.html#a09949638cf7d516ce9ad6dfff2475031">PV::InputLayer::normalizePixels</a></div><div class="ttdeci">virtual void normalizePixels(int batchElement)</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00279">InputLayer.cpp:279</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html"><div class="ttname"><a href="classPV_1_1InputLayer.html">PV::InputLayer</a></div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8hpp_source.html#l00020">InputLayer.hpp:20</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a3aa228af1576848e24babc60abe05a39"><div class="ttname"><a href="classPV_1_1InputLayer.html#a3aa228af1576848e24babc60abe05a39">PV::InputLayer::ioParamsFillGroup</a></div><div class="ttdeci">virtual int ioParamsFillGroup(enum ParamsIOFlag ioFlag) override</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00424">InputLayer.cpp:424</a></div></div>
<div class="ttc" id="classPV_1_1Buffer_html"><div class="ttname"><a href="classPV_1_1Buffer.html">PV::Buffer&lt; float &gt;</a></div></div>
<div class="ttc" id="classPV_1_1CheckpointableFileStream_html"><div class="ttname"><a href="classPV_1_1CheckpointableFileStream.html">PV::CheckpointableFileStream</a></div><div class="ttdef"><b>Definition:</b> <a href="CheckpointableFileStream_8hpp_source.html#l00013">CheckpointableFileStream.hpp:13</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a8c84fd873f563ad4f21d0b073aab15ca"><div class="ttname"><a href="classPV_1_1InputLayer.html#a8c84fd873f563ad4f21d0b073aab15ca">PV::InputLayer::ioParam_triggerLayerName</a></div><div class="ttdeci">virtual void ioParam_triggerLayerName(enum ParamsIOFlag ioFlag) override</div><div class="ttdoc">triggerLayerName: Specifies the name of the layer that this layer triggers off of. If set to NULL or the empty string, the layer does not trigger but updates its state on every timestep. </div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00758">InputLayer.cpp:758</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_a8e993dd5a30ede37722a5e9d5a062662"><div class="ttname"><a href="classPV_1_1InputLayer.html#a8e993dd5a30ede37722a5e9d5a062662">PV::InputLayer::describeInput</a></div><div class="ttdeci">virtual std::string describeInput(int index)</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8hpp_source.html#l00201">InputLayer.hpp:201</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_ae52c187ac0eedc919213ab2a725e86df"><div class="ttname"><a href="classPV_1_1InputLayer.html#ae52c187ac0eedc919213ab2a725e86df">PV::InputLayer::ioParam_InitVType</a></div><div class="ttdeci">virtual void ioParam_InitVType(enum ParamsIOFlag ioFlag) override</div><div class="ttdoc">initVType: Specifies how to initialize the V buffer. </div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00753">InputLayer.cpp:753</a></div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_abca7df27e7a6356bacf07e20b0043fda"><div class="ttname"><a href="classPV_1_1InputLayer.html#abca7df27e7a6356bacf07e20b0043fda">PV::InputLayer::countInputImages</a></div><div class="ttdeci">virtual int countInputImages()=0</div></div>
<div class="ttc" id="classPV_1_1InputLayer_html_aabc8d136ac737da1d6dd2e72c286b5b2"><div class="ttname"><a href="classPV_1_1InputLayer.html#aabc8d136ac737da1d6dd2e72c286b5b2">PV::InputLayer::retrieveInput</a></div><div class="ttdeci">void retrieveInput(double timef, double dt)</div><div class="ttdef"><b>Definition:</b> <a href="InputLayer_8cpp_source.html#l00099">InputLayer.cpp:99</a></div></div>
<div class="ttc" id="classPV_1_1Checkpointer_html"><div class="ttname"><a href="classPV_1_1Checkpointer.html">PV::Checkpointer</a></div><div class="ttdef"><b>Definition:</b> <a href="Checkpointer_8hpp_source.html#l00025">Checkpointer.hpp:25</a></div></div>
<div class="ttc" id="namespacePV_html"><div class="ttname"><a href="namespacePV.html">PV</a></div><div class="ttdef"><b>Definition:</b> <a href="CheckpointableFileStream_8cpp_source.html#l00003">CheckpointableFileStream.cpp:3</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_661d761cf52f45dc0ac6ea1d43985b5f.html">OpenPV</a></li><li class="navelem"><a class="el" href="dir_a5a2402a07c448d7bb6699a067163b2e.html">src</a></li><li class="navelem"><a class="el" href="dir_9a91aecaef209e538db0ab8c7c763d88.html">layers</a></li><li class="navelem"><b>InputLayer.hpp</b></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
